////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Lite weight version of Nextion library.                                                                                    //
// Uses a fraction of the codespace, typically 4K less                                                                        //
// 10x faster due to not using delays except when blocking, good code won't generally use blocking                            //
// Library by Keith Colson - http://www.edns.co.nz/index.php/about/ - September 2017...                                       //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "nexlite.h"
#include "televisor.h" // purely for zero init optimisation

nl_struct ns;                             // main data struct to pass to callback
void (*nl_CallbackPtr)(struct nl_struct *ns); // stores the function pointer

bool nl_Init(void (*funcPtr)(struct nl_struct *ns)){ // connect to the nextion   
  bool tConnected = false;                // pass in a call back pointer so all events can be sent to it
  nl_struct *ns;                          // for the reutrn of the blocking call   
  NL_SERIAL.begin(NL_BAUD);               // open the nextion serial port
  nl_SendCommand2("");                    // these are done by the library
  nl_SendCommand2("bkcmd=1");  
  ns = nl_SendCommandWait();  
  nl_SendCommand2("page 0");  
  ns = nl_SendCommandWait();  
  tConnected = ns->prevId;
  nl_CallbackPtr = funcPtr;               // store function pointer for use on touch events generated by nl_Loop
  return tConnected;
}

void nl_Listen(void){                // this makes the get serial run and calls back if there is an event, handles partial packets for speed
  static uint8_t bufPos = 0;         // position in buffer
  static uint8_t fCnt = 0;           // footer counter, does not need initialisation (well, it auto-inits to 0, so let's do it manually and fix the warning anyway)
  if (NL_SERIAL.available())         // call it byte at a time and time slice very fast
  { 
    ns.buff[bufPos] = NL_SERIAL.read();
    //Serial.print(bufPos); Serial.print("   "); Serial.println(ns.buff[bufPos]);  
    if (ns.buff[bufPos] == 0xFF)     // could be a footer
    {
      fCnt++;                        // add one to the footer count
      if (fCnt == 3){                // 3 footer 0xFF so we have a complete packet now
        bufPos = 0;                  // reset the buffer position for the next packet 
        (*nl_CallbackPtr)(&ns);      // call the callback     
        return;                      // compiler actually optimies this out but it does make it nice to read
      }else{                         // we have 1 or 2 0xFF's now
        bufPos++;                    // increment the buffer position
      }
    }
    else{                            // not a footer
      fCnt = 0;                      // zero the footer count
      bufPos++;                      // increment the buffer position
    }
    if (bufPos > BUF_SIZE) bufPos = 0; // this should never happen but just to be safe    
  }
}

void nl_SendCommand2(const char* cmd){
  nl_SendCommand(cmd,'2');
}

void nl_SendFooter(void){            // private subroutine e.g. no public prototype
    NL_SERIAL.write(0xFF);
    NL_SERIAL.write(0xFF);
    NL_SERIAL.write(0xFF);
}

void nl_SendCommand(const char* cmd, uint8_t id)
{
    //Serial.print("nl_SendCommand: ");Serial.println(cmd);
    ns.prevId = id;                  // store id for two cycle instructions e.g. get v.val, store the v so when we
    NL_SERIAL.print(cmd);            // get the actual value we know what control it was
    nl_SendFooter();
}

void nl_GetVal(const char* var, uint8_t id)
{
    //Serial.print("nl_GetVal: ");Serial.println(var);
    ns.prevId = id;                  // store id for two cycle instructions e.g. get v.val, store the v so when we
    NL_SERIAL.print("get ");         // e.g. "get x.val"
    NL_SERIAL.print(var);
    NL_SERIAL.print(".val");         // e.g. "get x.val"    
    nl_SendFooter();
}

void nl_SetPage(uint8_t page)
{
    NL_SERIAL.print("page ");         // e.g. "get x.val"
    NL_SERIAL.print(page);
    nl_SendFooter();
}

// blocking version of send command that lame code or hacks can call haha
struct nl_struct *nl_SendCommandWait(void){
  uint8_t bufPos = 0;               // position in buffer
  uint8_t fCnt = 100;               // footer counter, does not need initialisation (let's do it anyway and remove the warning)
  while (fCnt--){                   // borrrow variable before main serial loop
    delay(1);
    if (NL_SERIAL.available())
      fCnt = 0;                     // serial has arrived to stop waiting
  }
  while (NL_SERIAL.available() > 0) // this is optional, can call it byte as time and work just the same
  {
    delay(4);                       // leave some time for the serial to load another byte
    ns.buff[bufPos] = NL_SERIAL.read();
    //Serial.print(bufPos); Serial.print("   "); Serial.println(ns.buff[bufPos]);  
    if (ns.buff[bufPos] == 0xFF)     // could be a footer
    {
      fCnt++;                        // add one to the footer count
      if (fCnt == 3){                // 3 footer 0xFF so we have a complete packet now
        bufPos = 0;                  // reset the buffer position for the next packet 
        ns.prevId = 'Y';             // success
        return &ns;                  // compiler actually optimies this out but it does make it nice to read
      }else{                         // we have 1 or 2 0xFF's now
        bufPos++;                    // increment the buffer position
      }
    }
    else{                            // not a footer
      fCnt = 0;                      // zero the footer count
      bufPos++;                      // increment the buffer position
    }
    if (bufPos > BUF_SIZE) bufPos = 0; // this should never happen but just to be safe
  }
  ns.prevId = false;                 // fail
  return &ns;
}
